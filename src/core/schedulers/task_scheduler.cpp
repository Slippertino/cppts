#include "core/schedulers/task_scheduler.hpp"
#include <iostream>

namespace cppts {

TaskSchedulerBuilder TaskScheduler::create() {
	return TaskSchedulerBuilder();
}

void TaskScheduler::set_concurrency_size(size_t sz) {
	_upm.set_concurrency_size(sz);
}

void TaskScheduler::run() {
	TaskSchedulerBase::run();
	_upm.notify_scheduler_run(_settings.name);

	TS_LOG(_settings.logger, INFO) << "Root TS [ " << _settings.name << " ] was run.";
}

void TaskScheduler::stop() {
	TaskSchedulerBase::stop();
	_upm.notify_scheduler_stop(_settings.name);

	TS_LOG(_settings.logger, INFO) << "Root TS [ " << _settings.name << " ] was stopped.";
}

TaskScheduler::~TaskScheduler() {
	stop();

	TS_LOG(_settings.logger, INFO) << "Root TS [ " << _settings.name << " ] is destroying...";

	unregister_scheduler(_settings.name);
}

void TaskScheduler::init(
	std::shared_ptr<TaskSchedulerBase> parent,
	TaskSchedulerParameters&& settings
) {
	TaskSchedulerBase::init(parent, std::move(settings));

	if (!_upm.try_register_scheduler(_settings.name)) {
		throw_exception<failed_ts_registration_error>(
			_settings.name,
			"root scheduler with such domain name has been already registered in UPM"
		);
	}

	add_system_block();

	TS_LOG(_settings.logger, INFO) << "Root TS [ " << _settings.name << " ] was successfully initialized.";
}

void TaskScheduler::add_system_block() {
	static const auto sys_trigger_name = "sys_trigger";
	static const auto sys_task_name = "sys_task";

	auto sys_trigger = TriggerBuilder::create()
		.name(sys_trigger_name)
		.interval_sec(2)
		.forever()
		.depends_on(_settings.switcher)
		.build();

	try_add_trigger(std::move(sys_trigger));

	auto sys_task = TaskBuilder::create<TaskDefault>()
		.name(sys_task_name)
		.policy(SYNC)
		.max_pool_size(1)
		.emplace_logger<DefaultLogger>()
		.set_task<void>([&]() {
			_scheduler_blocks_containers_mutex.lock_shared();

			for (auto& blocks : _scheduler_blocks_containers) {
				blocks.second.erase_disabled();
			}

			_scheduler_blocks_containers_mutex.unlock_shared();
		})
		.build();

	this->add_block()
		.set_trigger(sys_trigger_name)
		.add_task(std::move(sys_task))
		.build();
}

bool TaskScheduler::is_block_registered(
	const std::string ts_name,
	const std::string& block_name
) const {
	_scheduler_blocks_containers_mutex.lock_shared();

	auto res = _scheduler_blocks_containers.at(ts_name).is_exist(block_name);

	_scheduler_blocks_containers_mutex.unlock_shared();

	return res;
}

bool TaskScheduler::try_register_scheduler(const std::string& ts_name) {
	std::lock_guard<std::shared_mutex> locker(_scheduler_blocks_containers_mutex);

	if (_scheduler_blocks_containers.find(ts_name) != _scheduler_blocks_containers.end()) {
		TS_LOG(_settings.logger, INFO)
			<< "Failed registration for TS [ " << ts_name << " ] by root TS [ " << _settings.name << " ].";

		return false;
	}

	_scheduler_blocks_containers.insert({ ts_name, ProcessableBlocksContainer() });

	TS_LOG(_settings.logger, INFO)
		<< "New TS [ " << ts_name << " ] was registered by root TS [ " << _settings.name << " ].";

	return true;
}

void TaskScheduler::unregister_scheduler(const std::string& ts_name) {
	std::lock_guard<std::shared_mutex> locker(_scheduler_blocks_containers_mutex);

	_scheduler_blocks_containers.erase(ts_name);

	TS_LOG(_settings.logger, INFO)
		<< "TS [ " << ts_name << " ] was unregistered by root TS [ " << _settings.name << " ].";
}

std::string TaskScheduler::generate_block_name(
	const std::string& ts_name,
	const std::string& trigger_name,
	std::function<bool(const std::string&)> pred
) const {
	_scheduler_blocks_containers_mutex.lock_shared();

	auto& blocks = _scheduler_blocks_containers.at(ts_name);

	auto res = NamesFormatter::apply_with_condition_block_name_style(
		ts_name,
		trigger_name,
		[&pred, &blocks](const std::string& s) {
			return pred(s) && !blocks.is_exist(s);
		}
	);

	_scheduler_blocks_containers_mutex.unlock_shared();

	TS_LOG(_settings.logger, DEBUG)
		<< "New block name [ " << res << " ] " 
		<< "for TS [ " << ts_name << " ] " 
		<< "and its trigger [ " << trigger_name << " ] " 
		<< "was generated by root Ts [ " << _settings.name << " ].";

	return res;
}

void TaskScheduler::register_block(
	const std::string& ts_name,
	const std::string& block_name,
	std::shared_ptr<BlockComposite> block
) {
	_scheduler_blocks_containers_mutex.lock_shared();

	auto& blocks = _scheduler_blocks_containers.at(ts_name);
	blocks.add(block_name, block);

	std::list<std::weak_ptr<IUnitProcessable>> units{ block };
	units.splice(units.end(), block->get_tasks());
	_upm
		.get_scheduler_processes(_settings.name)
		.add(std::move(units));

	_scheduler_blocks_containers_mutex.unlock_shared();

	TS_LOG(_settings.logger, INFO)
		<< "New block [ " << block_name << " ] was registered "
		<< "for TS [ " << ts_name << " ] "
		<< "by root TS [ " << _settings.name << " ].";
}

} // namespace cppts